}
###############################################################################
# Plotagem do Gr?fico de Cotovelo - WSS vs. K
plot(wss, main = "nrow*variances")
pretty_palette <- c("#1f77b4", '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2')
#################  Hierarchical Clustering - hclust()  #########################
#################  Distance Matrix Computation dist()  #########################
##### Monta Clusters da Matriz de Distancias entre os Neuronios ###########
#### cuttree()  -  Cut a Tree into Groups of Data
### Cuts a tree, e.g., as resulting from hclust, into several groups either by specifying the desired number(s) of groups or the cut height(s)
#### cutree(tree, k = NULL, h = NULL)
som_cluster <- cutree(hclust(dist(as.data.frame(som_model$codes))), 6)
plot(som_cluster)
plot(som_model, type="mapping", bgcol = pretty_palette[som_cluster], main = "Clusters")
add.cluster.boundaries(som_model, som_cluster)
getwd()
setwd("/resources/data/SOM_IC")
setwd("C://Users//samue//Desktop//alpha//Sistemas de Informação//Quinto Semestre//probabilidade e estatistica")
getwd()
hemograma <- read.csv("hemograma4.CSV", header = TRUE, sep = ";")
summary(hemograma)
View(hemograma)
head(hemograma)
#install.packages("plotly")
library(plotly)
require(plotly)
fig <- plot_ly(x = hemograma$Patient.age.quantile,type="histogram")
fig <- fig %>% layout(title="Histograma Patient.age.quantile", xaxis=list(title="Idade em Quantil"),yaxis=list(title="Quantidade"))
fig
fig <- plot_ly(hemograma, labels = ~hemograma$SARS.Cov.2.exam.result,type = 'pie')
fig
fig <- plot_ly(hemograma, x = seq(1:598), y = ~hemograma$Hematocrit, name = 'Hematocrit', type = 'scatter', mode = 'lines+markers')
fig <- fig %>% add_trace(y = ~hemograma$Hemoglobin, name = 'Hemoglobin', mode = 'lines+markers')
fig <- fig %>% add_trace(y = ~hemograma$Platelets, name = 'Platelets', mode = 'lines+markers')
fig <- fig %>% layout(title="Análises de Sangue",xaxis=list(title="Pacientes"))
fig
fig <- plot_ly(hemograma, x = ~hemograma$Hemoglobin, y = ~hemograma$SARS.Cov.2.exam.result, type = 'scatter', mode = 'markers')
fig <- fig %>% layout(title="Gráfico de Hemoglobin x Exam Result",xaxis=list(title="Hemoglobin"),yaxis=list(title="SARS.Cov.2.exam.result"))
fig
fig <- plot_ly(hemograma, x = ~hemograma$Hemoglobin, y = ~hemograma$Leukocytes, type = 'scatter', mode = 'markers')
fig <- fig %>% layout(title="Gráfico de Hemoglobin x Leukocytes",xaxis=list(title="Hemoglobin"),yaxis=list(title="Leukocytes"))
fig
fig <- plot_ly(hemograma, x = ~hemograma$Hemoglobin, y = ~hemograma$Leukocytes, type = 'scatter', mode = 'markers',color=~hemograma$SARS.Cov.2.exam.result)
fig <- fig %>% layout(title="Gráfico de Hemoglobin x Leukocytes",xaxis=list(title="Hemoglobin"),yaxis=list(title="Leukocytes"))
fig
fig <- plot_ly(data = hemograma, x = ~hemograma$Patient.addmited.to.regular.ward..1.yes..0.no., y = ~hemograma$Hematocrit)
#install.packages("plotly")
library(plotly)
require(plotly)
fig <- plot_ly(data = hemograma, x = ~hemograma$Patient.addmited.to.regular.ward..1.yes..0.no., y = ~hemograma$Hematocrit)
fig
fig <- plot_ly(data = hemograma, x = ~hemograma$SARS.Cov.2.exam.result.BIN, y = ~hemograma$Patient.age.quantile)
fig
fig <- plot_ly(
x = hemograma$Patient.age.quantile,
y = hemograma$Patient.addmited.to.regular.ward..1.yes..0.no.,
name = "resultado por idade",
type = "bar"
)
fig
a <- c(2,5, 6, 8, 10, 11, 15, 15, 16, 17, 20, 25)
summary(a)
b <- c(23, 37, 45, 49, 56, 63, 63, 70, 72, 82)
summary(b)
sqrt(284,6)
x <- (284,6)
x <- 284,6
sqrt(x)
x <- 284,6
x <- 284.6
sqrt(x)
a <- c( 8, 11, 20, 10, 2, 17, 15, 5, 16, 15, 25, 6)
summary(a)
getwd()
setwd("C:/Users/samue/Documents/www/IC/Scientific_Initiation/src")
library(kohonen)
require(kohonen)
df <- read.csv('database/uscitiesCsv.csv', header = TRUE, sep = ",")
# Dellaware DATA FRAME with 2 Var (latitude and longitude), 77 cities
df_del <- df[621:697, c(9,10,11)]
# data normalization
data_train_matrix <- as.matrix(scale(df_del))
som_grid <- somgrid(xdim = 4, ydim = 4, topo="hexagonal") # SOM 6x6, hexagonal
som_model <- som(data_train_matrix,
grid=som_grid,
rlen=100,
alpha=c(0.05,0.01),
keep.data = TRUE,
radius = 5)
#plots of SOM model
plot(som_model, type="changes")
#quantidade de amostras mapeadas em cada node (centroide)
plot(som_model, type="count", main = "node counts")
plot(som_model, type="dist.neighbours", main = "SOM neighbour distances")
#aaa
plot(som_model, type="codes", main = "codes")
som_model$unit.classif
#heatmaps:
#allows the visualisation of the distribution of a single variable across the map
plot(som_model, type = "property",
property = getCodes(som_model)[,1],
main=colnames(getCodes(som_model))[1])
plot(som_model, type = "property",
property = getCodes(som_model)[,2],
main=colnames(getCodes(som_model))[2])
plot(som_model, type = "property",
property = getCodes(som_model)[,3],
main=colnames(getCodes(som_model))[3])
# Montagem de DF com os Neur?nios do SOM para Washington
mydata <- as.data.frame(som_model$codes)
# cALCULANDO sOMAS DE qUADRADOS (Vari?ncias) para o Mydata - WASHINGTON
wss <- (nrow(mydata)-1)*sum(apply(mydata,2,var))
######### Clusteriza??o dos N?s do SOM, pelo K-means (variando o K) ###########
# Registra a Varia??o Interna (WSS) de cada Cluster e Soma essas varia??es
for (i in 2:15) {
wss[i] <- sum(kmeans(mydata, centers=i)$withinss)
}
###############################################################################
# Plotagem do Gr?fico de Cotovelo - WSS vs. K
plot(wss, main = "nrow*variances")
pretty_palette <- c("#1f77b4", '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2')
#################  Hierarchical Clustering - hclust()  #########################
#################  Distance Matrix Computation dist()  #########################
##### Monta Clusters da Matriz de Distancias entre os Neuronios ###########
#### cuttree()  -  Cut a Tree into Groups of Data
### Cuts a tree, e.g., as resulting from hclust, into several groups either by specifying the desired number(s) of groups or the cut height(s)
#### cutree(tree, k = NULL, h = NULL)
som_cluster <- cutree(hclust(dist(as.data.frame(som_model$codes))), 6)
plot(som_cluster)
plot(som_model, type="mapping", bgcol = pretty_palette[som_cluster], main = "Clusters")
add.cluster.boundaries(som_model, som_cluster)
som_cluster
colnames(localiz) <- c("node")
#centroides de cada estado (16)
centroides <- as.data.frame(som_model$codes)
plot(centroides)
View(centroides)
#pontos de demanda
plot(data_train_matrix)
#pontos de demanda
plot(data_train_matrix)
library(ggplot2)
require(ggplot2)
#population
df_del_population <- df[621:697, c(1,11)] #population column
grid_size <- 2.3
#vetor com distâncias entre os customers e warehouses, e centroides para sua media
customerDistanceVector <- c()
#vetor com distâncias entre a média da posição dos centroides, e cada um deles
centroidDistanceVector <- c()
#vector with costs based in distance
centroid_costPerSquareMeter <- c()
customerCostVector <- c()
centroidCostVector <- c()
#indica a qual warehouse cada customer está atrelado
localiz <- as.matrix(som_model$unit.classif)
m <- 16 #usado em warehouse locations, id
n <- 77 #usado em customer locations, id
D <- 0
x_mean <- mean(centroides[,1]) #media x dos centroides
y_mean <- mean(centroides[,2]) #media y dos centroides
centroid_id <- 16
#calcula o custo do transporte entre o ponto de demanda e o seu armazÃ©m
distanc <- function(Xc, Yc, Xw, Yw){
distance <- sqrt((Xw-Xc)**2+(Yw-Yc)**2)
return(distance)
}
#data frame customer locations
customer_locations <- data.frame(
id = 1:n,
x = data_train_matrix[,1],
y = data_train_matrix[,2],
localiz,
population = df_del_population$population
)
View(customer_locations)
#calculation of dist of centroid locations mean, and locations
for(val in 1:centroid_id){
D <- distanc(centroides$lat[[val]], centroides$lng[[val]],
x_mean, y_mean)
centroidDistanceVector[val] <- D
}
View(centroidDistanceVector)
#def of quartiles of distances between centroids mean and its locations
quartile1 <- quantile(centroidDistanceVector, 0.25)
quartile2 <- quantile(centroidDistanceVector, 0.5)
quartile3 <- q
quartile3 <- quantile(centroidDistanceVector, 0.75)
for(val in 1:centroid_id){
if(centroidDistanceVector[val] <= quartile1){
centroid_costPerSquareMeter[val] <- 2000 #custo por metro quadrado
}
if(centroidDistanceVector[val] > quartile1 && centroidDistanceVector[val] <= quartile2){
centroid_costPerSquareMeter[val] <- 1500
}
if(centroidDistanceVector[val] > quartile2 && centroidDistanceVector[val] <= quartile3){
centroid_costPerSquareMeter[val] <- 1000
}
if(centroidDistanceVector[val] > quartile3 ){
centroid_costPerSquareMeter[val] <- 500
}
}
View(centroid_costPerSquareMeter)
#soma a população de cada centroide
clustPop <- c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
for(i in 1:m){
for(j in 1:n){
if(customer_locations$localiz[j] == i){
clustPop[i] <- clustPop[i] + customer_locations$population[j]
}
}
}
#calc of warehouse size and cost
warehouse_costs <- c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
warehouse_size <- c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
meter_per_habitant <- 1
for(i in 1:16){
warehouse_size[i] <- clustPop[i] * meter_per_habitant
warehouse_costs[i] <- warehouse_size[i] * centroid_costPerSquareMeter[i]
}
warehouse_locations <- data.frame(
id = 1:centroid_id,
x = centroides[,1],
y = centroides[,2],
dist_to_mean = centroidDistanceVector, #dist of each waarehouse to all warehouse mean
cost_per_square_meter = centroid_costPerSquareMeter, #cost based on dist_to_mean quartiles (line 162)
total_population = clustPop,
warehouse_size = warehouse_size, #size based on population
warehouse_costs = warehouse_costs #cost based on warehouse_size and cost_per_square_meter
)
#calc of dist between customer and respectives warehouses
for(val in customer_locations$id){
D <- distanc(customer_locations$x[[val]], customer_locations$y[[val]],
warehouse_locations$x[[customer_locations$localiz[[val]]]],
warehouse_locations$y[[customer_locations$localiz[[val]]]])
customerDistanceVector[val] <- D
customerCostVector[val] <- D * 2.5
}
#transport cost calculation
calc_transport_dist <- function(id){
vec <- c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
for(centroid_counter in 1:77){
D <- distanc(customer_locations$x[[centroid_counter]], customer_locations$y[[centroid_counter]],
warehouse_locations$x[[id]], warehouse_locations$y[[id]])
vec[centroid_counter] <- D * 2.5
}
return(vec)
}
transport_cost <- data.frame(
centroide1 = calc_transport_dist(1),
centroide2 = calc_transport_dist(2),
centroide3 = calc_transport_dist(3),
centroide4 = calc_transport_dist(4),
centroide5 = calc_transport_dist(5),
centroide6 = calc_transport_dist(6),
centroide7 = calc_transport_dist(7),
centroide8 = calc_transport_dist(8),
centroide9 = calc_transport_dist(9),
centroide10 = calc_transport_dist(10),
centroide11 = calc_transport_dist(11),
centroide12 = calc_transport_dist(12),
centroide13 = calc_transport_dist(13),
centroide14 = calc_transport_dist(14),
centroide15 = calc_transport_dist(15),
centroide16 = calc_transport_dist(16)
)
#prove
print(
distanc(customer_locations$x[[4]], customer_locations$y[[4]],
warehouse_locations$x[[1]], warehouse_locations$y[[1]])
)
#principal PLOT
p <- ggplot(customer_locations, aes(x, y)) +
geom_point() +
geom_point(data = warehouse_locations, color = "red", alpha = 0.5, shape = 17) +
scale_x_continuous(limits = c(-1.6, grid_size)) +
scale_y_continuous(limits = c(-1.6, grid_size)) +
theme(axis.title = element_blank(),
axis.ticks = element_blank(),
axis.text = element_blank(), panel.grid = element_blank())
p + ggtitle("Warehouse location problem",
"Black dots are customers. Light red triangles show potential warehouse locations.")
#solving model
library(ompr)
library(magrittr)
warehouse_costs
model <- MIPModel() %>%
# 1 iff i gets assigned to warehouse j
add_variable(x[i, j], i = 1:n, j = 1:m, type = "binary") %>%
# 1 iff warehouse j is built
add_variable(y[j], j = 1:m, type = "binary") %>%
# maximize the preferences
set_objective(sum_expr(transportcost[i, j] * x[i, j], i = 1:n, j = 1:m) +    #trocar por transport_cost[i,j]
sum_expr(warehouse_costs[j] * y[j], j = 1:m), "min") %>%           #trocar por warehouse_costs[j]
# every customer needs to be assigned to a warehouse
add_constraint(sum_expr(x[i, j], j = 1:m) == 1, i = 1:n) %>%
# if a customer is assigned to a warehouse, then this warehouse must be built
add_constraint(x[i,j] <= y[j], i = 1:n, j = 1:m)
#solving model
library(ompr)
library(magrittr)
model <- MIPModel() %>%
# 1 iff i gets assigned to warehouse j
add_variable(x[i, j], i = 1:n, j = 1:m, type = "binary") %>%
# 1 iff warehouse j is built
add_variable(y[j], j = 1:m, type = "binary") %>%
# maximize the preferences
set_objective(sum_expr(transportcost[i, j] * x[i, j], i = 1:n, j = 1:m) +    #trocar por transport_cost[i,j]
sum_expr(warehouse_costs[j] * y[j], j = 1:m), "min") %>%           #trocar por warehouse_costs[j]
# every customer needs to be assigned to a warehouse
add_constraint(sum_expr(x[i, j], j = 1:m) == 1, i = 1:n) %>%
# if a customer is assigned to a warehouse, then this warehouse must be built
add_constraint(x[i,j] <= y[j], i = 1:n, j = 1:m)
#solving model
library(ompr)
library(magrittr)
n <- 77
m <- 16
model <- MIPModel() %>%
# 1 iff i gets assigned to warehouse j
add_variable(x[i, j], i = 1:n, j = 1:m, type = "binary") %>%
# 1 iff warehouse j is built
add_variable(y[j], j = 1:m, type = "binary") %>%
# maximize the preferences
set_objective(sum_expr(transportcost[i, j] * x[i, j], i = 1:n, j = 1:m) +    #trocar por transport_cost[i,j]
sum_expr(warehouse_costs[j] * y[j], j = 1:m), "min") %>%           #trocar por warehouse_costs[j]
# every customer needs to be assigned to a warehouse
add_constraint(sum_expr(x[i, j], j = 1:m) == 1, i = 1:n) %>%
# if a customer is assigned to a warehouse, then this warehouse must be built
add_constraint(x[i,j] <= y[j], i = 1:n, j = 1:m)
transportcost_func <- function(i, j) {
customer <- customer_locations[i, ]
warehouse <- warehouse_locations[j, ]
round(sqrt((customer$x - warehouse$x)^2 + (customer$y - warehouse$y)^2))
}
transportcost_func(1,3)
transportcost_func(1,1)
transportcost_func(1,2)
#transport cost calculation
calc_transport_dist <- function(id){
vec <- c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
for(centroid_counter in 1:77){
D <- distanc(customer_locations$x[[centroid_counter]], customer_locations$y[[centroid_counter]],
warehouse_locations$x[[id]], warehouse_locations$y[[id]])
vec[centroid_counter] <- D * 2.5
}
return(vec)
}
transport_cost <- data.frame(
centroide1 = calc_transport_dist(1),
centroide2 = calc_transport_dist(2),
centroide3 = calc_transport_dist(3),
centroide4 = calc_transport_dist(4),
centroide5 = calc_transport_dist(5),
centroide6 = calc_transport_dist(6),
centroide7 = calc_transport_dist(7),
centroide8 = calc_transport_dist(8),
centroide9 = calc_transport_dist(9),
centroide10 = calc_transport_dist(10),
centroide11 = calc_transport_dist(11),
centroide12 = calc_transport_dist(12),
centroide13 = calc_transport_dist(13),
centroide14 = calc_transport_dist(14),
centroide15 = calc_transport_dist(15),
centroide16 = calc_transport_dist(16)
)
View(transport_cost)
transportcost_func(1,2)
View(customer_locations)
View(warehouse_locations)
customer_locations[1,]
yayaya <- customer_locations[1,]
yayaya$x
transportcost_func <- function(i, j) {
customer <- customer_locations[i, ]
warehouse <- warehouse_locations[j, ]
round(sqrt((customer$x - warehouse$x)^2 + (customer$y - warehouse$y)^2))
}
#prove
print(
distanc(customer_locations$x[[4]], customer_locations$y[[4]],
warehouse_locations$x[[1]], warehouse_locations$y[[1]])
)
transportcost_func(4,1)
#prove
print(
distanc(customer_locations$x[[1]], customer_locations$y[[1]],
warehouse_locations$x[[1]], warehouse_locations$y[[1]])
)
#prove
print(
distanc(customer_locations$x[[1]], customer_locations$y[[1]],
warehouse_locations$x[[1]], warehouse_locations$y[[1]])
)
transportcost_func(1,1)
transportcost_func <- function(i, j) {
customer <- customer_locations[i, ]
warehouse <- warehouse_locations[j, ]
sqrt((customer$x - warehouse$x)^2 + (customer$y - warehouse$y)^2)
}
transportcost_func(1,1)
#solving model
library(ompr)
library(magrittr)
n <- 77
m <- 16
model <- MIPModel() %>%
# 1 iff i gets assigned to warehouse j
add_variable(x[i, j], i = 1:n, j = 1:m, type = "binary") %>%
# 1 iff warehouse j is built
add_variable(y[j], j = 1:m, type = "binary") %>%
# maximize the preferences
set_objective(sum_expr(transportcost_func(i, j) * x[i, j], i = 1:n, j = 1:m) +    #trocar por transport_cost[i,j]
sum_expr(warehouse_costs[j] * y[j], j = 1:m), "min") %>%           #trocar por warehouse_costs[j]
# every customer needs to be assigned to a warehouse
add_constraint(sum_expr(x[i, j], j = 1:m) == 1, i = 1:n) %>%
# if a customer is assigned to a warehouse, then this warehouse must be built
add_constraint(x[i,j] <= y[j], i = 1:n, j = 1:m)
model
set.seed(1234)
grid_size <- 1000
#Xn?mero de clientes
n <- 100
customer_locations <- data.frame(
id = 1:n,
x = round(runif(n) * grid_size),
y = round(runif(n) * grid_size)
)
#-----warehouses are also randomly placed on the grid
m <- 20
warehouse_locations <- data.frame(
id = 1:m,
x = round(runif(m) * grid_size),
y = round(runif(m) * grid_size)
)
#-------rnorm() X generates multivariate normal random variates in the space X
fixedcost <- round(rnorm(m, mean = grid_size * 10, sd = grid_size * 5))
# -----build a functions that takes a customer and a warehouse and returns the transport cost
transportcost <- function(i, j) {
customer <- customer_locations[i, ]
warehouse <- warehouse_locations[j, ]
round(sqrt((customer$x - warehouse$x)^2 + (customer$y - warehouse$y)^2))
}
transportcost(1, 3)
#-------plot everything
library(ggplot2)
p <- ggplot(customer_locations, aes(x, y)) +
geom_point() +
geom_point(data = warehouse_locations, color = "red", alpha = 0.5, shape = 17) +
scale_x_continuous(limits = c(0, grid_size)) +
scale_y_continuous(limits = c(0, grid_size)) +
theme(axis.title = element_blank(),
axis.ticks = element_blank(),
axis.text = element_blank(), panel.grid = element_blank())
p + ggtitle("Warehouse location problem",
"Black dots are customers. Light red triangles show potential warehouse locations.")
#
#---------------model in ompr
#################objetivo#####################
library(ompr)
library(magrittr)
model <- MIPModel() %>%
# 1 iff i gets assigned to warehouse j
add_variable(x[i, j], i = 1:n, j = 1:m, type = "binary") %>%
# 1 iff warehouse j is built
add_variable(y[j], j = 1:m, type = "binary") %>%
# maximize the preferences
set_objective(sum_expr(transportcost(i, j) * x[i, j], i = 1:n, j = 1:m) +    #trocar por transport_cost[i,j]
sum_expr(fixedcost[j] * y[j], j = 1:m), "min") %>%           #trocar por warehouse_costs[j]
# every customer needs to be assigned to a warehouse
add_constraint(sum_expr(x[i, j], j = 1:m) == 1, i = 1:n) %>%
# if a customer is assigned to a warehouse, then this warehouse must be built
add_constraint(x[i,j] <= y[j], i = 1:n, j = 1:m)
model
#--------solving model in glpk
library(ompr.roi)
library(ROI.plugin.glpk)
result <- solve_model(model, with_ROI(solver = "glpk", verbose = TRUE))
suppressPackageStartupMessages(library(dplyr))
matching <- result %>%
get_solution(x[i,j]) %>%
filter(value > .9) %>%
select(i, j)
#####OBJETIVO######
#add the assignments to the previous plot
plot_assignment <- matching %>%
inner_join(customer_locations, by = c("i" = "id")) %>%
inner_join(warehouse_locations, by = c("j" = "id"))
customer_count <- matching %>% group_by(j) %>% summarise(n = n()) %>% rename(id = j)
plot_warehouses <- warehouse_locations %>%
mutate(costs = fixedcost) %>%
inner_join(customer_count, by = "id") %>%
filter(id %in% unique(matching$j))
p +
geom_segment(data = plot_assignment, aes(x = x.y, y = y.y, xend = x.x, yend = y.x)) +
geom_point(data  = plot_warehouses, color = "red", size = 3, shape = 17) +
ggrepel::geom_label_repel(data  = plot_warehouses,
aes(label = paste0("fixed costs:", costs, "; customers: ", n)),
size = 2, nudge_y = 20) +
ggtitle(paste0("Cost optimal warehouse locations and customer assignment"),
"Big red triangles show warehouses that will be built, light red are unused warehouse locations.
Dots represent customers served by the respective warehouses.")
#fixed costs for setting up the 4 warehouses:
sum(fixedcost[unique(matching$j)])
